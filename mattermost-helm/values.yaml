global:
  # Set siteUrl to the URL your users will use to access Mattermost
  siteUrl: ""
  dbBackend: "mysqlha"
  dbRootPassword: "rootpasswd"
  dbUser: "mmuser"
  dbPassword: "passwd"
  dbName: "mattermost"
  filesAccessKey: mattermostadmin
  filesSecretKey: mattermostadmin
  mattermostLicense: "THIS STRING SHOULD BE REPLACED WITH THE CONTENTS OF YOUR LICENSE FILE"
  features:
    elasticsearch:
      enabled: false
    loadTest:
      enabled: false
    grafana:
      enabled: false
    jobserver:
      name: jobserver
      enabled: false
      replicaCount: 1
      service:
        name: mattermost-app-jobserver
        type: ClusterIP
    notifications:
      # Push proxy must be configured or useHPNS must be true for push noticiations to work.
      push:
        enabled: false
        # Hosted push notification service. Requires an enterprise license.
        # More details at https://docs.mattermost.com/mobile/mobile-hpns.html.
        useHPNS: false
    linkPreviews:
      enabled: false
    customEmoji:
      enabled: false

tags:
  ingress: false
  metrics: false
  storage: true
  database: true

mysqlha:
  enabled: true
  mysqlha:
    replicaCount: 2
    mysqlRootPassword: "rootpasswd"
    mysqlUser: "mmuser"
    mysqlPassword: "passwd"
    mysqlDatabase: "mattermost"
    configFiles:
      master.cnf: |
        [mysqld]
        log-bin
        skip_name_resolve
      slave.cnf: |
        [mysqld]
        super-read-only
        skip_name_resolve
        slave_parallel_workers = 100
        slave_parallel_type = LOGICAL_CLOCK
  persistence:
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, azure-disk on
    ##   Azure, standard on GKE, AWS & OpenStack)
    ##
    # storageClass: "-"
    ## Enable persistence using Persistent Volume Claims
    ## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
    ##
    ## See: https://github.com/kubernetes/charts/tree/master/incubator/mysqlha
    enabled: false
    size: 10Gi

postgresql:
  enabled: false
  postgresUser: "mmuser"
  postgresPassword: "passwd"
  postgresDatabase: "mattermost"
  persistence:
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, azure-disk on
    ##   Azure, standard on GKE, AWS & OpenStack)
    ##
    # storageClass: "-"
    ## Enable persistence using Persistent Volume Claims
    ## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
    ##
    ## See: https://github.com/kubernetes/charts/tree/master/incubator/mysqlha
    enabled: false
    size: 10Gi

mattermost-app:
  replicaCount: 2
  image:
    repository: mattermost/mattermost-enterprise-edition
    tag: 5.0.0

tls:
  # When enabled kube-lego will use Let's Encrypt to get a SSL cert
  enabled: false
  # Host name the SSL cert will be registered for
  hostname: example.com

kube-lego:
  enabled: false
  config:
    # Replace this email with the one for registering your SSL cert
    LEGO_EMAIL: someone@example.com
    # Defaults to the staging environment, update to https://acme-v01.api.letsencrypt.org/directory for production
    LEGO_URL: https://acme-staging.api.letsencrypt.org/directory
  rbac:
    # Set to true if your Kubernetes cluster has RBAC enabled
    create: true

nginx-ingress:
  enabled: false
  controller:
    config:
      http-snippet: |
        proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=mattermost_cache:10m max_size=3g inactive=120m use_temp_path=off;
  rbac:
    # Set to true if your Kubernetes cluster has RBAC enabled
    create: true

mattermost-elasticsearch:
  client:
    replicaCount: 2
  master:
    replicaCount: 3
  data:
    replicaCount: 2

mattermost-loadtest:
  replicaCount: 1
  numTeams: 1
  numChannelsPerTeam: 400
  numUsers: 1000
  numPosts: 20000000
  numEmoji: 2000
  replyChance: 0.3
  skipBulkLoad: true
  testLengthMinutes: 20
  numActiveEntities: 1000
  actionRateMilliseconds: 60000
  actionRateMaxVarianceMilliseconds: 15000
  linkPreviewChance: 0.2
  customEmojiChance: 0.2
  pprofDelayMinutes: 15
  pprofLengthSeconds: 240
  sendReportToMMServer: false
  resultsServerUrl: ""
  resultsChannelId: ""
  resultsUsername: ""
  resultsPassword: ""

mattermost-push-proxy:
  replicaCount: 1
  applePushSettings:
    apple:
      configMap: "apple-cert-path"
      privateCert: ""
      privateCertPassword: ""
      pushTopic: "com.mattermost.Mattermost"
    apple_rn:
      configMap: "apple-rn-cert-path"
      privateCert: ""
      privateCertPassword: ""
      pushTopic: "com.mattermost.react.native"
    apple_rnbeta:
      configMap: "apple-rnbeta-cert-path"
      privateCert: ""
      privateCertPassword: ""
      pushTopic: ""
  androidPushSettings:
    android:
      apiKey: ""
    android_rn:
      apiKey: ""

# Minio access/secret keys for the in-cluster S3 usage
# See https://github.com/kubernetes/charts/tree/master/stable/minio#configuration
# for more configuration options
# Minio is not exposed publically
minio:
  enabled: true
  imageTag: RELEASE.2018-05-25T19-49-13Z
  serviceType: ClusterIP
  accessKey: mattermostadmin
  secretKey: mattermostadmin
  nodeSelector: {}
  persistence:
    enabled: true
  # See https://docs.minio.io/docs/minio-server-configuration-guide
  minioConfig:
    region: ""
    browser: "off"
    domain: ""
    standardStorageClass: ""
    reducedRedundancyStorageClass: ""
    aqmp:
      enable: false
      url: ""
      exchange: ""
      routingKey: ""
      exchangeType: ""
      deliveryMode: 0
      mandatory: false
      immediate: false
      durable: false
      internal: false
      noWait: false
      autoDeleted: false
    nats:
      enable: false
      address: ""
      subject: ""
      username: ""
      password: ""
      token: ""
      secure: false
      pingInterval: 0
      enableStreaming: false
      clusterID: ""
      clientID: ""
      async: false
      maxPubAcksInflight: 0
    elasticsearch:
      enable: false
      format: "namespace"
      url: ""
      index: ""
    redis:
      enable: false
      format: "namespace"
      address: ""
      password: ""
      key: ""
    postgresql:
      enable: false
      format: "namespace"
      connectionString: ""
      table: ""
      host: ""
      port: ""
      user: ""
      password: ""
      database: ""
    kafka:
      enable: false
      brokers: "null"
      topic: ""
    webhook:
      enable: false
      endpoint: ""
    mysql:
      enable: false
      format: "namespace"
      dsnString: ""
      table: ""
      host: ""
      port: ""
      user: ""
      password: ""
      database: ""
    mqtt:
      enable: false
      broker: ""
      topic: ""
      qos: 0
      clientId: ""
      username: ""
      password: ""

# See https://github.com/kubernetes/charts/tree/master/stable/prometheus#configuration
# for more configuration options
prometheus:
  enabled: false
  alertmanager:
    enabled: false
    ingress:
      enabled: false
  configmapReload:
    name: configmap-reload
  kubeStateMetrics:
    enabled: false
  nodeExporter:
    enabled: false
  pushgateway:
    enabled: false
  rbac:
    # Set to true if your Kubernetes cluster has RBAC enabled
    create: true
  server:
    name: server
    ingress:
      enabled: false
    persistentVolume:
      enabled: false
    replicaCount: 1
    service:
      servicePort: 9090
  serviceAccounts:
    alertmanager:
      create: false
    kubeStateMetrics:
      create: false
    nodeExporter:
      create: false
    pushgateway:
      create: false
  serverFiles:
    prometheus.yml:
      global:
        scrape_interval: 15s
      rule_files:
        - /etc/config/rules
        - /etc/config/alerts
      scrape_configs:
        - job_name: prometheus
          static_configs:
            - targets:
              - localhost:9090
        - job_name: 'mattermost-app'
          scrape_interval: 5s
          kubernetes_sd_configs:
            - role: pod
          relabel_configs:
            - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
              action: keep
              regex: true
            - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
              action: replace
              target_label: __metrics_path__
              regex: (.+)
            - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
              action: replace
              regex: (.+):(?:\d+);(\d+)
              replacement: ${1}:${2}
              target_label: __address__
            - action: labelmap
              regex: __meta_kubernetes_pod_label_(.+)
            - source_labels: [__meta_kubernetes_namespace]
              action: replace
              target_label: kubernetes_namespace
            - source_labels: [__meta_kubernetes_pod_name]
              action: replace
              #regex: __meta_kubernetes_pod_label_app(.*)
              target_label: kubernetes_pod_name
